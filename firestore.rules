/**
 * Core Philosophy: This ruleset implements a role-based access control system centered
 * around 'Admins'. An admin's status is determined by the existence of a document in the
 * /roles_admin collection. Admins have the authority to create and manage events.
 *
 * Data Structure:
 * - /admins/{adminId}: Private profile data for each admin, accessible only by the admin themselves.
 * - /roles_admin/{adminId}: A collection used for role management. The existence of a document
 *   at /roles_admin/{userId} grants that user admin privileges. This collection is not
 *   writable by clients to ensure security.
 * - /events/{eventId}: A public collection of events that anyone can read. Write access is
 *   restricted to the admin who created the event.
 * - /events/{eventId}/bookings/{bookingId}: A subcollection for bookings related to an event.
 *   Bookings can be created by anyone (e.g., via a public checkout form), but can only be
 *   read or managed by the admin who owns the parent event.
 *
 * Key Security Decisions:
 * - Admin Role Management: The /roles_admin collection is read-only for clients. Roles must be
 *   assigned out-of-band (e.g., via the Firebase Console or a trusted server-side process).
 *   This prevents users from elevating their own privileges.
 * - Public vs. Private Data: The /events collection is publicly readable to allow users to
 *   browse events. All other data, including admin profiles and event bookings, is private
 *   and requires specific authorization to access.
 * - Default Deny: All operations are denied by default. Access is only granted through
 *   explicit 'allow' statements.
 *
 * Denormalization for Authorization:
 * - The `events` collection contains a denormalized `adminId` field. This allows security
 *   rules to verify event ownership directly from the event document without needing to perform
 *   extra reads, resulting in faster and more efficient rule execution.
 *
 * Structural Segregation:
 * - Public event data (/events) is stored separately from private admin data (/admins) and
 *   role data (/roles_admin). This clear separation simplifies rules and prevents accidental
 *   data leakage through list queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    
    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for establishing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the requesting user has an admin role.
     * Admin status is granted if a document with the user's UID exists in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the requesting user is the admin who owns the parent event.
     * This requires reading the parent event document.
     */
    function isEventAdmin(eventId) {
      let eventAdminId = get(/databases/$(database)/documents/events/$(eventId)).data.adminId;
      return isOwner(eventAdminId);
    }
    
    /**
     * Validates that the incoming admin profile data contains an `id` field
     * that matches the document's path ID. Used only on create.
     */
    function incomingAdminDataIsValid(adminId) {
      return request.resource.data.id == adminId;
    }

    /**
     * Ensures critical relational fields are not changed during an update.
     */
    function isImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }
    
    /**
     * On create, validates the incoming event has an owner matching the requestor
     * and that the document ID matches the path.
     */
    function incomingEventDataIsValid(eventId) {
      let incomingData = request.resource.data;
      return incomingData.adminId == request.auth.uid
             && incomingData.id == eventId;
    }

    /**
     * On create, validates that incoming booking data is correctly linked
     * to its path.
     */
    function incomingBookingDataIsValid(eventId, bookingId) {
      let incomingData = request.resource.data;
      return incomingData.eventId == eventId
             && incomingData.id == bookingId;
    }
    
    /**
     * @description
     *   Admin user profiles. Only the owner of the profile can read or write to it.
     *   Listing admin profiles is disallowed to prevent user enumeration.
     * @path /admins/{adminId}
     * @allow (get) An authenticated user with UID 'admin123' reading their own document at /admins/admin123.
     * @deny (get) User 'user456' trying to read /admins/admin123.
     * @principle Restricts access to a user's own data tree.
     */
    match /admins/{adminId} {
      allow get: if isOwner(adminId);
      allow list: if false;
      allow create: if isOwner(adminId) && incomingAdminDataIsValid(adminId);
      allow update: if isOwner(adminId) && resource != null && isImmutable('id');
      allow delete: if isOwner(adminId) && resource != null;
    }

    /**
     * @description
     *   Role-granting documents. The existence of a document here makes a user an admin.
     *   This collection is locked down from all client-side operations to prevent users from
     *   escalating their own privileges. Roles must be managed via the server or Firebase Console.
     * @path /roles_admin/{adminId}
     * @allow (none) No client operation is permitted.
     * @deny (create) Any user trying to create a document to make themselves an admin.
     * @principle Prevents privilege escalation by making role assignments a server-side-only operation.
     */
    match /roles_admin/{adminId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description
     *   Publicly readable event data. Anyone can view events, but only an authenticated admin
     *   can create events, and only the original creator can update or delete them.
     * @path /events/{eventId}
     * @allow (list) Any user, signed in or not, listing all documents in the /events collection.
     * @deny (create) A non-admin user trying to create a new event.
     * @principle Implements a "Public Read with Owner-Only Writes" pattern, enforced by an admin role check.
     */
    match /events/{eventId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin() && incomingEventDataIsValid(eventId);
      allow update: if isAdmin() && isOwner(resource.data.adminId) && resource != null && isImmutable('id') && isImmutable('adminId');
      allow delete: if isAdmin() && isOwner(resource.data.adminId) && resource != null;

      /**
       * @description
       *   Bookings for a specific event. Anyone can create a booking (e.g., a public form),
       *   but only the admin who created the parent event can read, list, update, or delete bookings.
       * @path /events/{eventId}/bookings/{bookingId}
       * @allow (create) An anonymous user submitting data to create a new booking document.
       * @deny (get) A regular user trying to read booking details for an event.
       * @principle Secures a subcollection by checking ownership data on the parent document.
       */
      match /bookings/{bookingId} {
        allow get: if isAdmin() && isEventAdmin(eventId);
        allow list: if isAdmin() && isEventAdmin(eventId);
        allow create: if incomingBookingDataIsValid(eventId, bookingId);
        allow update: if isAdmin() && isEventAdmin(eventId) && resource != null && isImmutable('id') && isImmutable('eventId');
        allow delete: if isAdmin() && isEventAdmin(eventId) && resource != null;
      }
    }
  }
}